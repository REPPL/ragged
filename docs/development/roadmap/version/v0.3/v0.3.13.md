# v0.3.13 - Polish & Integration

**Category:** API, Web, Final UX

**Estimated Time:** 26-32 hours

**Status:** Planned

---

## Overview

REST API, refined UX, accessibility, complete documentation - v0.3 production-ready release.

**Target Users:** Developers (API), all users (UX/accessibility), web integrations

**Key Innovation:** FastAPI REST server enables web integration, smart suggestions improve query quality, accessibility features ensure inclusive design.

**Milestone:** Final v0.3 release - production-ready RAG system with comprehensive features, excellent UX, and complete documentation.

---

## Prerequisites

**Security & Privacy Foundation (REQUIRED):**

All v0.3.x versions depend on the security and privacy infrastructure established in v0.2.10 and v0.2.11. These versions MUST be completed before implementing any v0.3.x features.

- âœ… **v0.2.10 (Security Hardening)** - Eliminates Pickle vulnerabilities, implements session isolation, establishes security testing framework
- âœ… **v0.2.11 (Privacy Infrastructure)** - Provides encryption at rest, PII detection/redaction, data lifecycle management, GDPR compliance

**Why Required:** v0.3.13 launches REST API server supporting multiple users. v0.2.10 provides session isolation to prevent cross-user data leakage, and v0.2.11 provides encryption and privacy controls for API requests.

---

## Features

### CLI-020: API Server Mode (8-10h)

**Priority:** Critical
**Dependencies:** All v0.3.x features

#### Scope

FastAPI REST server exposing ragged functionality via HTTP API.

**Use Cases:**
- Web application integration
- Mobile app backends
- Microservices architecture
- Remote ragged instances
- Multi-client access
- Third-party integrations

**API Design:**

```yaml
openapi: 3.0.0
info:
  title: ragged REST API
  version: 0.3.13

paths:
  /documents:
    get:
      summary: List documents
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            default: 100
        - name: offset
          in: query
          schema:
            type: integer
            default: 0
      responses:
        '200':
          description: List of documents
          content:
            application/json:
              schema:
                type: object
                properties:
                  documents:
                    type: array
                    items:
                      $ref: '#/components/schemas/Document'
                  total:
                    type: integer

    post:
      summary: Add document
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
      responses:
        '201':
          description: Document added
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Document'

  /documents/{document_id}:
    get:
      summary: Get document details
      parameters:
        - name: document_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Document details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Document'

    delete:
      summary: Delete document
      parameters:
        - name: document_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '204':
          description: Document deleted

  /query:
    post:
      summary: Query documents
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                question:
                  type: string
                filters:
                  type: object
                top_k:
                  type: integer
                  default: 5
                show_reasoning:
                  type: boolean
                  default: false
      responses:
        '200':
          description: Query result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QueryResult'

  /retrieve:
    post:
      summary: Retrieve chunks without generation
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                question:
                  type: string
                top_k:
                  type: integer
                  default: 5
      responses:
        '200':
          description: Retrieved chunks
          content:
            application/json:
              schema:
                type: object
                properties:
                  chunks:
                    type: array
                    items:
                      $ref: '#/components/schemas/Chunk'

  /metrics:
    get:
      summary: Get quality metrics
      responses:
        '200':
          description: Quality metrics
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Metrics'

  /health:
    get:
      summary: Health check
      responses:
        '200':
          description: Service healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    example: healthy
                  version:
                    type: string
                    example: 0.3.13

components:
  schemas:
    Document:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        path:
          type: string
        size_bytes:
          type: integer
        chunks:
          type: integer
        created_at:
          type: string
          format: date-time

    Chunk:
      type: object
      properties:
        id:
          type: string
        content:
          type: string
        metadata:
          type: object
        confidence:
          type: number
        document_id:
          type: string

    QueryResult:
      type: object
      properties:
        answer:
          type: string
        chunks:
          type: array
          items:
            $ref: '#/components/schemas/Chunk'
        reasoning:
          type: array
          items:
            type: string
        confidence:
          type: number

    Metrics:
      type: object
      properties:
        ragas:
          type: object
          properties:
            context_precision:
              type: number
            context_recall:
              type: number
            faithfulness:
              type: number
            answer_relevancy:
              type: number
```

**User Experience:**

```bash
$ ragged serve --host 0.0.0.0 --port 8000

ðŸš€ ragged API Server

Version: v0.3.13
Host: 0.0.0.0
Port: 8000
Docs: http://localhost:8000/docs
ReDoc: http://localhost:8000/redoc

[2024-01-15 14:30:00] INFO: Server started
[2024-01-15 14:30:15] INFO: POST /query - 200 (1.2s)
[2024-01-15 14:30:42] INFO: GET /documents - 200 (0.05s)

Press Ctrl+C to stop

$ curl -X POST http://localhost:8000/query \
  -H "Content-Type: application/json" \
  -d '{
    "question": "What are the main findings?",
    "top_k": 5
  }'

{
  "answer": "The main findings include...",
  "chunks": [
    {
      "id": "doc1_chunk_007",
      "content": "The study found that...",
      "confidence": 0.95,
      "document_id": "doc1"
    }
  ],
  "confidence": 0.92
}
```

#### Implementation Overview

- **Module:** `src/api/server.py`
- **Approach:** FastAPI framework with async support
- **Libraries:** fastapi, uvicorn, pydantic
- **Integration:** Exposes all ragged functionality

#### Key Components

- FastAPI application
- Pydantic models for request/response
- Async endpoint handlers
- CORS middleware
- Authentication (optional, API keys)
- Rate limiting
- OpenAPI documentation (auto-generated)
- WebSocket support (streaming responses)

---

### CLI-021: Smart Suggestions (5-6h)

**Priority:** High
**Dependencies:** v0.3.1 (RAGAS), v0.3.3 (query decomposition)

#### Scope

Intelligent query refinement suggestions to improve retrieval quality.

**Use Cases:**
- Vague queries needing clarification
- Spelling corrections
- Query expansion suggestions
- Related queries
- Optimal query formulation

**User Experience:**

```bash
$ ragged query "wat r main finding"

ðŸ’¡ Smart Suggestions

Your query: "wat r main finding"

Did you mean?
  â†’ "What are the main findings?"  (spelling correction)

Suggested refinements:
  â†’ "What are the main findings of this research?"  (more specific)
  â†’ "Summarise the key findings"  (clearer intent)

Related queries you might ask:
  â†’ "What methodology was used?"
  â†’ "What are the limitations?"
  â†’ "What future work is suggested?"

[Press Enter to use original query, or type number to use suggestion]
Choice: 1

Using: "What are the main findings?"

ðŸ“„ Retrieved 5 chunks (0.94 avg confidence)

Answer: The main findings include...

$ ragged query --suggest "machine learning" --auto-refine

ðŸ’¡ Auto-refining query...

Original: "machine learning"
Refined: "What are the key concepts in machine learning covered in these documents?"

Reason: Vague keyword â†’ specific question

ðŸ“„ Retrieved 5 chunks (0.89 avg confidence)

Answer: The key concepts in machine learning covered include...

$ ragged query "deep learning applications" --related-queries

ðŸ“‹ Related Queries

Based on your query "deep learning applications", you might also ask:
  1. "What are the common architectures for deep learning?"
  2. "What datasets are used for deep learning applications?"
  3. "What are the challenges in deploying deep learning models?"
  4. "How does deep learning compare to traditional machine learning?"

[Enter number to run, or press Enter to skip]
```

#### Implementation Overview

- **Module:** `src/generation/suggestions.py`
- **Approach:** LLM-based query analysis and refinement
- **Libraries:** spellchecker (spelling), difflib (similarity)
- **Integration:** Pre-query pipeline stage

#### Key Components

- `QuerySuggester` class
- Spelling correction
- Query refinement (vague â†’ specific)
- Related query generation
- Query quality scoring
- User interaction prompts

---

### CLI-022: Colour Themes & Accessibility (3-4h)

**Priority:** Medium
**Dependencies:** None

#### Scope

Customisable colour themes and accessibility features for inclusive design.

**Use Cases:**
- Visual impairments (high contrast)
- Colour blindness (colourblind-safe palettes)
- Personal preferences (dark/light themes)
- Terminal compatibility
- Accessibility compliance (WCAG 2.1 AA)

**User Experience:**

```bash
$ ragged config set theme dark

âœ“ Theme set to: dark
  Colours optimised for dark terminals

$ ragged config set theme light

âœ“ Theme set to: light
  Colours optimised for light backgrounds

$ ragged config set theme high-contrast

âœ“ Theme set to: high-contrast
  Enhanced contrast for accessibility (WCAG 2.1 AA compliant)

$ ragged config set theme colourblind-safe

âœ“ Theme set to: colourblind-safe
  Colourblind-friendly palette (deuteranopia, protanopia, tritanopia safe)

$ ragged config set theme monochrome

âœ“ Theme set to: monochrome
  No colours (symbols only)

$ ragged query "test" --theme dark

[Output with dark theme colours]

$ ragged config get theme

Current theme: dark

Available themes:
  â€¢ dark             - Dark terminal optimised (default)
  â€¢ light            - Light background optimised
  â€¢ high-contrast    - WCAG 2.1 AA compliant
  â€¢ colourblind-safe - Colourblind-friendly
  â€¢ monochrome       - No colours (accessible)
  â€¢ custom           - User-defined (see config.yaml)
```

**Accessibility Features:**

- Screen reader compatibility (structured output)
- Keyboard navigation (interactive mode)
- No colour-only information (symbols + colours)
- Adjustable text size (via terminal)
- Clear focus indicators
- Semantic HTML in web outputs

#### Implementation Overview

- **Module:** `src/cli/themes.py`
- **Approach:** rich library theming + accessibility guidelines
- **Libraries:** rich (styling), wcag-contrast-ratio (validation)
- **Integration:** Global configuration

#### Key Components

- `ThemeManager` class
- Predefined themes (dark, light, high-contrast, colourblind-safe, monochrome)
- Custom theme support
- WCAG contrast validation
- Theme preview
- Colour palette definitions

---

## Privacy & Security Implementation

**Critical Privacy Requirements:** REST API server supports multiple users/clients over network. MUST prevent cross-user data leakage and protect all user requests using v0.2.10/v0.2.11 infrastructure.

### Multi-User Session Isolation (v0.2.10 Integration)

**1. Per-Client Session Management**

Each API client gets isolated session using v0.2.10:

```python
# src/api/server.py - FastAPI with session isolation
from fastapi import FastAPI, Request, HTTPException
from src.core.session import get_session_manager, Session
from src.security.encryption import get_encryption_manager

app = FastAPI(
    title="ragged REST API",
    version="0.3.13",
    description="Privacy-first RAG system API"
)

# Middleware for session management
@app.middleware("http")
async def session_middleware(request: Request, call_next):
    """Create/retrieve session for each API client (v0.2.10)."""
    session_mgr = get_session_manager()

    # Get session ID from header or create new
    session_id = request.headers.get("X-Session-ID")

    if session_id:
        session = session_mgr.get_or_create_session(session_id)
    else:
        # New session
        session = session_mgr.get_or_create_session()
        session_id = session.session_id

    # Attach session to request state
    request.state.session = session

    # Process request
    response = await call_next(request)

    # Return session ID in response header
    response.headers["X-Session-ID"] = session_id

    return response
```

**Session Lifecycle:**
- **Creation:** First API request creates new session
- **Identification:** Client includes `X-Session-ID` header in subsequent requests
- **Isolation:** Each session has isolated cache, history, state
- **Expiration:** Sessions expire after inactivity (v0.2.11 TTL)

**2. Session-Scoped Cache Isolation**

API responses cached per-session (v0.2.10):

```python
# Query endpoint with session-scoped caching
from src.retrieval.cache import QueryCache

@app.post("/query", response_model=QueryResponse)
async def query_documents(
    request: QueryRequest,
    req: Request
) -> QueryResponse:
    """Query with session-isolated cache (v0.2.10)."""
    session = req.state.session

    # Cache lookup uses session ID (v0.2.10)
    cache = QueryCache()
    cached = cache.get(
        query=request.question,
        session_id=session.session_id,  # âœ… Session-scoped
        top_k=request.top_k
    )

    if cached:
        return QueryResponse.from_cached(cached)

    # Execute query
    result = ragged_client.query(
        question=request.question,
        filters=request.filters,
        top_k=request.top_k
    )

    # Cache result for this session only
    cache.set(
        query=request.question,
        results=result.chunks,
        session_id=session.session_id  # âœ… Session-scoped
    )

    return QueryResponse.from_result(result)
```

**Privacy Guarantee:** Client A's cached queries NEVER visible to Client B

**3. Session Cleanup on Disconnect**

Sessions automatically cleaned up using v0.2.11:

```python
# Session cleanup for API
from src.core.cleanup import get_cleanup_scheduler

def cleanup_api_sessions() -> int:
    """Clean up expired API sessions (v0.2.11)."""
    from src.config.settings import get_settings
    settings = get_settings()

    session_mgr = get_session_manager()
    timeout = settings.session_ttl_days * 86400

    removed = session_mgr.cleanup_expired_sessions(timeout)

    logger.info(f"Cleaned up {removed} expired API sessions")
    return removed

# Register with v0.2.11 cleanup scheduler
cleanup_scheduler = get_cleanup_scheduler()
cleanup_scheduler.register_cleanup_task(cleanup_api_sessions)
```

**Default:** Sessions expire after 24 hours of inactivity

### Request/Response Privacy (v0.2.11 Integration)

**1. Request Logging Privacy**

API requests logged with query hashing (v0.2.11):

```python
# Privacy-safe API logging
from src.security.pii import hash_query, contains_pii
import logging

logger = logging.getLogger(__name__)

@app.post("/query")
async def query_documents(request: QueryRequest):
    """Query endpoint with privacy-safe logging."""
    # Hash query for logging (v0.2.11)
    query_hash = hash_query(request.question)

    # Log only hash, NOT plaintext
    logger.info(
        f"API query received: hash={query_hash[:16]}, "
        f"top_k={request.top_k}, "
        f"filters={bool(request.filters)}"
    )

    # Warn if PII detected
    if contains_pii(request.question):
        logger.warning(f"Query hash {query_hash[:16]} may contain PII")

    # Process query...
```

**Logged:** Query hash, parameters
**NOT Logged:** Actual query text, answers, document content

**2. Rate Limiting per Client**

Prevent abuse and cache poisoning:

```python
# Rate limiting with session awareness
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/query")
@limiter.limit("100/hour")  # Per IP address
async def query_documents(request: QueryRequest, req: Request):
    """Query with rate limiting."""
    # Rate limited per IP + session
    # Prevents one user from:
    # - Poisoning cache for others
    # - DoS attacks
    # - Excessive data collection
```

**Limits:**
- 100 queries/hour per IP address
- Configurable per deployment
- Helps prevent privacy attacks

**3. Response Sanitization**

Sensitive data removed from responses:

```python
# Response models with privacy
from pydantic import BaseModel

class QueryResponse(BaseModel):
    answer: str
    chunks: List[ChunkResponse]
    confidence: float
    # NO: session_id (would expose internal state)
    # NO: cache_key (would expose hashing)
    # NO: document_paths (could reveal user's file system)

class ChunkResponse(BaseModel):
    content: str
    page: Optional[int]
    confidence: float
    # document_id instead of full path
    document_id: str  # Hashed, not actual filename
```

**Privacy:** Internal identifiers hashed or sanitized before exposure

### Authentication & Authorization

**1. API Key Authentication**

Require authentication for API access:

```python
# API key authentication
from fastapi import Security, HTTPException
from fastapi.security.api_key import APIKeyHeader

API_KEY_HEADER = APIKeyHeader(name="X-API-Key", auto_error=False)

async def get_api_key(api_key: str = Security(API_KEY_HEADER)):
    """Validate API key."""
    from src.config.settings import get_settings
    settings = get_settings()

    if not api_key or api_key not in settings.api_keys:
        raise HTTPException(
            status_code=403,
            detail="Invalid or missing API key"
        )

    return api_key

@app.post("/query")
async def query_documents(
    request: QueryRequest,
    api_key: str = Depends(get_api_key)  # âœ… Authentication required
):
    """Authenticated query endpoint."""
    # Process query...
```

**Security:**
- All endpoints require valid API key
- API keys stored encrypted (v0.2.11)
- Keys rotatable without service restart

**2. Per-Key Rate Limiting**

Different rate limits for different API keys:

```python
# Per-key rate limiting
class APIKeyManager:
    def get_rate_limit(self, api_key: str) -> str:
        """Get rate limit for API key."""
        # Different tiers
        if api_key in premium_keys:
            return "1000/hour"
        elif api_key in standard_keys:
            return "100/hour"
        else:
            return "10/hour"  # Free tier

@app.post("/query")
@limiter.limit(lambda: get_key_rate_limit(request.state.api_key))
async def query_documents(request: QueryRequest):
    """Query with per-key rate limiting."""
```

### CORS Security

**Strict CORS Configuration:**

```python
# CORS configuration (NOT allow_origins=["*"])
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://app.example.com",      # Production web app
        "https://staging.example.com",  # Staging
        "http://localhost:3000"         # Local development
    ],  # âœ… Explicit allowlist (NOT ["*"])
    allow_credentials=True,
    allow_methods=["GET", "POST"],      # Only needed methods
    allow_headers=["X-API-Key", "X-Session-ID", "Content-Type"],
    max_age=3600,  # Cache preflight for 1 hour
)
```

**Security:** Prevents unauthorized cross-origin requests

### WebSocket Privacy

WebSocket streaming requires session management:

```python
# WebSocket with session isolation
from fastapi import WebSocket

@app.websocket("/ws/query")
async def websocket_query(websocket: WebSocket):
    """WebSocket streaming with session isolation."""
    await websocket.accept()

    try:
        # Authenticate via first message
        auth_msg = await websocket.receive_json()
        api_key = auth_msg.get("api_key")

        if not await validate_api_key(api_key):
            await websocket.close(code=1008, reason="Invalid API key")
            return

        # Create session for this WebSocket connection
        session_mgr = get_session_manager()
        session = session_mgr.get_or_create_session()

        # Send session ID
        await websocket.send_json({
            "type": "session_created",
            "session_id": session.session_id
        })

        # Process queries with session isolation
        while True:
            data = await websocket.receive_json()
            query = data.get("query")

            # Query hash for logging (v0.2.11)
            query_hash = hash_query(query)
            logger.info(f"WebSocket query: {query_hash[:16]}")

            # Stream response (session-scoped cache)
            async for chunk in stream_query(query, session.session_id):
                await websocket.send_json(chunk)

    except WebSocketDisconnect:
        # Clean up session on disconnect
        session_mgr.clear_session(session.session_id)
        logger.info(f"WebSocket disconnected, session cleared: {session.session_id[:8]}...")
```

**Privacy:**
- Each WebSocket connection = isolated session
- Session cleaned up on disconnect
- Query hashing in logs

### Audit Logging

Track API access for security:

```python
# Audit log for API access
class AuditLogger:
    def log_api_request(
        self,
        endpoint: str,
        method: str,
        session_id: str,
        api_key_hash: str,
        ip_address: str,
        status_code: int
    ) -> None:
        """Log API request (audit trail)."""
        # Store in separate audit database
        audit_db.insert({
            "timestamp": datetime.now(),
            "endpoint": endpoint,
            "method": method,
            "session_id": session_id,
            "api_key_hash": api_key_hash,  # Hashed, not plaintext
            "ip_address": ip_address,
            "status_code": status_code
        })

        # Audit logs have separate retention (longer TTL)
        # Default: 1 year for security audit
```

**Stored:** Access patterns, not content
**NOT Stored:** Query text, answers, document content

### Privacy Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| Cross-user cache leakage | NONE | N/A | Session-scoped caching (v0.2.10) |
| API logs contain queries | NONE | N/A | Query hashing (v0.2.11) |
| Unauthorized access | LOW | HIGH | API key authentication |
| CORS attacks | LOW | MEDIUM | Strict CORS allowlist |
| DoS/abuse | MEDIUM | MEDIUM | Rate limiting per key |
| Session hijacking | LOW | HIGH | Secure session IDs (UUID v4) |

**Privacy Score:** 92/100 (Excellent with v0.2.10/v0.2.11)

**Why 92/100 (not 100):**
- API keys transmitted in headers (use HTTPS in production)
- Audit logs retain IP addresses (privacy vs security trade-off)

### Recommendations for Production

**1. HTTPS Only**

```python
# Force HTTPS in production
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

if not settings.debug:
    app.add_middleware(HTTPSRedirectMiddleware)
```

**2. API Key Rotation**

```bash
# Rotate API keys regularly
$ ragged api keys rotate --key premium_key_001
âš ï¸  This will invalidate the old key. Continue? (y/n): y
âœ“ New key: ak_xxxxxxxxxxx
âœ“ Old key invalidated
```

**3. Security Headers**

```python
# Security headers
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000"
    return response
```

### Implementation Checklist

**Privacy Requirements:**
- [ ] Per-client session isolation (v0.2.10)
- [ ] Session-scoped cache (no cross-user leakage)
- [ ] Query hashing in logs (v0.2.11)
- [ ] API key authentication required
- [ ] Rate limiting per key/IP
- [ ] CORS strict allowlist (not `*`)
- [ ] WebSocket session management
- [ ] Session cleanup on disconnect
- [ ] Audit logging (access patterns only)
- [ ] HTTPS redirect in production

**Testing:**
- [ ] Test session isolation (Client A â‰  Client B cache)
- [ ] Verify query hashing in logs (no plaintext)
- [ ] Test authentication (invalid keys rejected)
- [ ] Test rate limiting (enforced)
- [ ] Test CORS (unauthorized origins blocked)
- [ ] Test WebSocket session cleanup
- [ ] Verify HTTPS redirect
- [ ] Test API key rotation

---

## Implementation Phases

### Phase 1: Design & Architecture (4-6h)

**Sessions 1-2:**
- Use ux-architect agent for API and accessibility design
- Design REST API endpoints
- Design OpenAPI schema
- Design query suggestion prompts
- Plan accessibility compliance

**Deliverables:**
- API specification (OpenAPI)
- Suggestion algorithm designed
- Accessibility guidelines documented

### Phase 2: API Server Implementation (8-11h)

**Sessions 3-5:**
- Implement FastAPI application
- Pydantic models for all endpoints
- Async endpoint handlers
- CORS middleware
- Authentication (API keys)
- Rate limiting
- WebSocket streaming
- OpenAPI docs
- Unit tests
- Integration tests
- API client examples (Python, JavaScript)

**Deliverables:**
- REST API fully functional
- Documentation auto-generated
- Tests passing

### Phase 3: Smart Suggestions Implementation (5-7h)

**Sessions 6-7:**
- Implement `QuerySuggester` class
- Spelling correction
- Query refinement logic
- Related query generation
- Quality scoring
- Interactive prompts
- CLI integration: `--suggest`, `--auto-refine`, `--related-queries`
- Unit tests

**Deliverables:**
- Suggestions working
- User prompts functional
- Tests passing

### Phase 4: Accessibility Implementation (3-5h)

**Sessions 8:**
- Implement `ThemeManager` class
- Define colour palettes
- WCAG contrast validation
- Theme switching
- CLI integration: `config set theme`
- Screen reader testing
- Unit tests

**Deliverables:**
- All themes implemented
- WCAG compliance validated
- Tests passing

### Phase 5: Integration & Polish (4-6h)

**Sessions 9-10:**
- Integration testing (all v0.3.x features)
- Performance testing
- UX refinement
- Bug fixing
- Edge case handling

**Deliverables:**
- All features integrated
- Performance acceptable
- UX polished

### Phase 6: Documentation & Release (6-8h)

**Session 11-12:**
- Use documentation-architect agent
- Complete user documentation
- API documentation (examples)
- Deployment guides
- Troubleshooting guides
- Use documentation-auditor agent (full codebase)
- Use git-documentation-committer agent
- Tag v0.3.13 release
- Release announcement

**Deliverables:**
- Complete documentation
- v0.3.0 production-ready release

---

## Technical Architecture

### Module Structure

```
src/api/
â”œâ”€â”€ server.py                   # FastAPI app (300 lines)
â”‚   â””â”€â”€ app: FastAPI
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ documents.py            # Document endpoints (200 lines)
â”‚   â”œâ”€â”€ query.py                # Query endpoints (150 lines)
â”‚   â”œâ”€â”€ metrics.py              # Metrics endpoints (100 lines)
â”‚   â””â”€â”€ health.py               # Health check (50 lines)
â”œâ”€â”€ models.py                   # Pydantic models (200 lines)
â”œâ”€â”€ auth.py                     # Authentication (150 lines)
â””â”€â”€ middleware.py               # CORS, rate limiting (100 lines)

src/generation/
â””â”€â”€ suggestions.py              # Smart suggestions (250 lines)
    â””â”€â”€ class QuerySuggester

src/cli/
â””â”€â”€ themes.py                   # Theme management (200 lines)
    â””â”€â”€ class ThemeManager

tests/api/
â”œâ”€â”€ test_server.py
â”œâ”€â”€ test_routes.py
â””â”€â”€ test_auth.py

docs/api/
â”œâ”€â”€ openapi.yaml                # Auto-generated
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ python_client.py
â”‚   â””â”€â”€ javascript_client.js
â””â”€â”€ deployment.md
```

### FastAPI Application

```python
from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional, List
import uvicorn

app = FastAPI(
    title="ragged REST API",
    version="0.3.13",
    description="Privacy-first RAG system API"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class QueryRequest(BaseModel):
    question: str
    filters: Optional[dict] = None
    top_k: int = 5
    show_reasoning: bool = False

class QueryResponse(BaseModel):
    answer: str
    chunks: List[dict]
    reasoning: Optional[List[str]] = None
    confidence: float

# Endpoints
@app.post("/query", response_model=QueryResponse)
async def query_documents(request: QueryRequest):
    """Query documents and generate answer."""
    try:
        result = ragged_client.query(
            question=request.question,
            filters=request.filters,
            top_k=request.top_k,
            show_reasoning=request.show_reasoning
        )

        return QueryResponse(
            answer=result.answer,
            chunks=[chunk.dict() for chunk in result.chunks],
            reasoning=result.reasoning if request.show_reasoning else None,
            confidence=result.confidence
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/documents")
async def add_document(file: UploadFile = File(...)):
    """Add document to library."""
    try:
        # Save uploaded file
        file_path = save_upload(file)

        # Process document
        result = ragged_client.add(file_path)

        return {
            "id": result.document_id,
            "name": file.filename,
            "chunks": result.chunk_count
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "version": "0.3.13"
    }

# Streaming endpoint (WebSocket)
@app.websocket("/query/stream")
async def query_stream(websocket: WebSocket):
    """Stream query results in real-time."""
    await websocket.accept()

    try:
        data = await websocket.receive_json()
        question = data["question"]

        # Stream chunks as they're retrieved
        async for chunk in ragged_client.query_stream(question):
            await websocket.send_json({
                "type": "chunk",
                "data": chunk.dict()
            })

        # Stream answer as it's generated
        async for token in ragged_client.generate_stream():
            await websocket.send_json({
                "type": "token",
                "data": token
            })

    except Exception as e:
        await websocket.send_json({
            "type": "error",
            "data": str(e)
        })
    finally:
        await websocket.close()

# Run server
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### Smart Suggestions

```python
class QuerySuggester:
    """Intelligent query refinement and suggestions."""

    def __init__(self, llm_client):
        self.llm = llm_client
        self.spellchecker = SpellChecker()

    def suggest(self, query: str) -> QuerySuggestions:
        """Generate query suggestions."""
        suggestions = QuerySuggestions(original=query)

        # 1. Spelling correction
        corrections = self._check_spelling(query)
        if corrections:
            suggestions.corrections = corrections

        # 2. Query refinement
        if self._is_vague(query):
            refined = self._refine_query(query)
            suggestions.refinements = refined

        # 3. Related queries
        related = self._generate_related(query)
        suggestions.related = related

        # 4. Quality score
        suggestions.quality_score = self._score_query(query)

        return suggestions

    def _check_spelling(self, query: str) -> List[str]:
        """Check and correct spelling."""
        words = query.split()
        corrections = []

        for word in words:
            if not self.spellchecker.correction(word) == word:
                corrected = self.spellchecker.correction(word)
                corrections.append(query.replace(word, corrected))

        return corrections[:3]  # Top 3 corrections

    def _is_vague(self, query: str) -> bool:
        """Detect vague queries."""
        # Heuristics
        word_count = len(query.split())
        has_question_word = any(
            q in query.lower()
            for q in ["what", "how", "why", "when", "where", "who"]
        )

        return word_count < 3 or not has_question_word

    def _refine_query(self, query: str) -> List[str]:
        """Refine vague query into specific questions."""
        prompt = f"""
        The user provided this vague query: "{query}"

        Generate 3 more specific and clear questions that would retrieve better results:
        1.
        2.
        3.
        """

        response = self.llm.generate(prompt)
        refinements = self._parse_refinements(response)
        return refinements

    def _generate_related(self, query: str) -> List[str]:
        """Generate related queries."""
        prompt = f"""
        Given this query: "{query}"

        Suggest 4 related questions the user might also want to ask:
        1.
        2.
        3.
        4.
        """

        response = self.llm.generate(prompt)
        related = self._parse_related(response)
        return related

    def _score_query(self, query: str) -> float:
        """Score query quality (0-1)."""
        score = 0.0

        # Has question word
        if any(q in query.lower() for q in ["what", "how", "why"]):
            score += 0.3

        # Sufficient length
        if len(query.split()) >= 5:
            score += 0.3

        # No spelling errors
        if not self._check_spelling(query):
            score += 0.2

        # Specific (not just keywords)
        if "?" in query or "How" in query or "What" in query:
            score += 0.2

        return min(score, 1.0)
```

### Theme System

```python
class ThemeManager:
    """Manage colour themes and accessibility."""

    THEMES = {
        "dark": {
            "success": "green",
            "error": "red",
            "warning": "yellow",
            "info": "cyan",
            "highlight": "magenta",
            "muted": "bright_black"
        },
        "light": {
            "success": "green",
            "error": "red",
            "warning": "yellow",
            "info": "blue",
            "highlight": "magenta",
            "muted": "black"
        },
        "high-contrast": {
            "success": "bright_green",
            "error": "bright_red",
            "warning": "bright_yellow",
            "info": "bright_cyan",
            "highlight": "bright_magenta",
            "muted": "white"
        },
        "colourblind-safe": {
            # Orange-blue palette (safe for most colourblindness types)
            "success": "blue",
            "error": "orange3",
            "warning": "yellow",
            "info": "cyan",
            "highlight": "blue",
            "muted": "bright_black"
        },
        "monochrome": {
            "success": "white",
            "error": "white",
            "warning": "white",
            "info": "white",
            "highlight": "white",
            "muted": "bright_black"
        }
    }

    def __init__(self, theme_name: str = "dark"):
        self.theme_name = theme_name
        self.theme = self.THEMES[theme_name]
        self._validate_contrast()

    def _validate_contrast(self):
        """Validate WCAG 2.1 AA contrast ratios."""
        from wcag_contrast_ratio import check_contrast

        # Validate that all colours meet WCAG 2.1 AA (4.5:1)
        for key, colour in self.theme.items():
            # Check against background (assume black or white)
            ratio = check_contrast(colour, "black")
            if ratio < 4.5:
                logger.warning(
                    f"Theme '{self.theme_name}': {key} colour fails WCAG AA"
                )

    def get_style(self, type: str) -> str:
        """Get colour for style type."""
        return self.theme.get(type, "white")

    def preview(self):
        """Preview theme colours."""
        from rich.console import Console
        from rich.table import Table

        console = Console()
        table = Table(title=f"Theme: {self.theme_name}")

        table.add_column("Type")
        table.add_column("Colour")
        table.add_column("Example")

        for key, colour in self.theme.items():
            table.add_row(
                key,
                colour,
                f"[{colour}]Sample text[/{colour}]"
            )

        console.print(table)
```

---

## Risk Analysis & Mitigation

**Risk 1: API Security**
- **Impact:** High - Unauthorised access
- **Probability:** Medium - API exposed to network
- **Mitigation:** Authentication (API keys), rate limiting, HTTPS only, input validation
- **Detection:** Security audits, penetration testing

**Risk 2: Query Suggestion Quality**
- **Impact:** Medium - Poor suggestions frustrate users
- **Probability:** Medium - LLM outputs vary
- **Mitigation:** Fallback to original query, user can skip suggestions, quality scoring
- **Detection:** User feedback, acceptance rate tracking

**Risk 3: Accessibility Compliance**
- **Impact:** Medium - Excludes users with disabilities
- **Probability:** Low - Following WCAG guidelines
- **Mitigation:** WCAG 2.1 AA compliance, testing with screen readers, colour contrast validation
- **Detection:** Accessibility audits, user testing

**Risk 4: API Performance**
- **Impact:** Medium - Slow API responses
- **Probability:** Medium - Queries can be slow
- **Mitigation:** Async handlers, caching, rate limiting, timeout configuration
- **Detection:** Performance monitoring, load testing

---

## Quality Gates

### Functional Requirements
- [ ] All API endpoints work correctly
- [ ] OpenAPI documentation accurate
- [ ] Authentication works
- [ ] Rate limiting works
- [ ] WebSocket streaming works
- [ ] Query suggestions generated correctly
- [ ] Spelling correction works
- [ ] Related queries relevant
- [ ] All themes display correctly
- [ ] Theme switching works
- [ ] WCAG contrast validation passes

### Performance Requirements
- [ ] API response time <2s for queries
- [ ] Suggestion generation <1s
- [ ] Theme switching instant
- [ ] WebSocket latency <100ms

### Security Requirements
- [ ] API keys required for protected endpoints
- [ ] Rate limiting prevents abuse
- [ ] Input validation prevents injection
- [ ] CORS configured correctly
- [ ] No sensitive data in logs

### Accessibility Requirements
- [ ] WCAG 2.1 AA compliance
- [ ] Screen reader compatible
- [ ] Keyboard navigation works
- [ ] No colour-only information
- [ ] High contrast theme validates

### Code Quality Requirements
- [ ] 100% test coverage for new code
- [ ] All tests passing
- [ ] Type hints complete
- [ ] Docstrings complete (British English)

---

## Execution Checklist

### Pre-Implementation
- [ ] Create branch: `git checkout -b feature/v0.3.13-polish-integration`
- [ ] Use ux-architect agent for API and accessibility design
- [ ] Design REST API (OpenAPI spec)
- [ ] Design suggestion prompts
- [ ] Plan accessibility compliance

### API Server Implementation
- [ ] Add dependencies: `fastapi>=0.104.0`, `uvicorn>=0.24.0`, `python-multipart>=0.0.6`
- [ ] Create `src/api/server.py`
- [ ] Implement FastAPI application
- [ ] Create Pydantic models
- [ ] Implement document endpoints
- [ ] Implement query endpoints
- [ ] Implement metrics endpoint
- [ ] Implement health endpoint
- [ ] CORS middleware
- [ ] Authentication (API keys)
- [ ] Rate limiting
- [ ] WebSocket streaming
- [ ] CLI command: `ragged serve`
- [ ] Unit tests
- [ ] Integration tests
- [ ] API client examples (Python, JavaScript)

### Smart Suggestions Implementation
- [ ] Add dependency: `pyspellchecker>=0.7.0`
- [ ] Create `src/generation/suggestions.py`
- [ ] Implement `QuerySuggester` class
- [ ] Spelling correction
- [ ] Query refinement (vague â†’ specific)
- [ ] Related query generation
- [ ] Quality scoring
- [ ] Interactive prompts
- [ ] CLI integration: `--suggest`, `--auto-refine`, `--related-queries`
- [ ] Unit tests

### Accessibility Implementation
- [ ] Add dependency: `wcag-contrast-ratio>=0.9`
- [ ] Create `src/cli/themes.py`
- [ ] Implement `ThemeManager` class
- [ ] Define all colour palettes (5 themes)
- [ ] WCAG contrast validation
- [ ] Theme preview command
- [ ] CLI integration: `config set theme`
- [ ] Screen reader testing
- [ ] Unit tests

### Integration & Testing
- [ ] Integration test all v0.3.x features
- [ ] API load testing
- [ ] Security testing (API)
- [ ] Accessibility testing (screen readers)
- [ ] Performance testing
- [ ] UX testing
- [ ] Bug fixes

### Documentation & Release
- [ ] Use documentation-architect agent
- [ ] Complete user documentation (all v0.3.x features)
- [ ] API documentation with examples
- [ ] Deployment guides (Docker, systemd)
- [ ] Troubleshooting guides
- [ ] Migration guides (if breaking changes)
- [ ] Run documentation-auditor agent (full codebase)
- [ ] Use git-documentation-committer agent
- [ ] Tag v0.3.13 release
- [ ] Create release notes
- [ ] Announce v0.3.0 complete

---

## Dependencies

```toml
[tool.poetry.dependencies]
fastapi = "^0.104.0"           # MIT - REST API framework
uvicorn = "^0.24.0"            # BSD - ASGI server
python-multipart = "^0.0.6"    # Apache 2.0 - File uploads
pyspellchecker = "^0.7.0"      # MIT - Spelling correction
wcag-contrast-ratio = "^0.9"   # MIT - Accessibility validation
```

---

## Agent Workflow (8-10h)

1. **ux-architect (2h):** API design and accessibility validation
2. **documentation-architect (3h):** Complete user-facing documentation for all v0.3.x
3. **documentation-auditor (3-4h):** Full codebase audit
4. **git-documentation-committer (1-2h):** Final commit

---

## Deliverables

1. **REST API** - FastAPI server with full ragged functionality
2. **OpenAPI Documentation** - Auto-generated, interactive
3. **Smart Suggestions** - Query refinement and related queries
4. **Colour Themes** - 5 themes including accessibility-focused
5. **WCAG Compliance** - AA standard met
6. **Complete Documentation** - User guides, API docs, deployment guides
7. **v0.3.0 Production Release** - All 13 versions complete

---

## Success Criteria

- âœ… REST API fully functional and documented
- âœ… API examples provided (Python, JavaScript)
- âœ… Smart suggestions improve query quality
- âœ… All themes work correctly and meet WCAG 2.1 AA
- âœ… Screen reader compatible
- âœ… All v0.3.x features integrated and tested
- âœ… Complete documentation for entire v0.3.x
- âœ… Production-ready release

---

## v0.3.0 Completion Milestone

**This release marks the completion of v0.3.0 - Production-Ready RAG System**

### v0.3.x Feature Summary (13 Versions)

1. **v0.3.1** - Foundation & Metrics (RAGAS baseline)
2. **v0.3.2** - Configuration Transparency (personas, presets)
3. **v0.3.3** - Advanced Query Processing (query decomposition, HyDE, reranking, compression)
4. **v0.3.4** - Intelligent Chunking (semantic, hierarchical)
5. **v0.3.5** - Modern Document Processing (Docling, 30Ã— performance)
6. **v0.3.6** - Messy Document Intelligence (automated PDF correction)
7. **v0.3.7** - VectorStore Abstraction (multi-database support)
8. **v0.3.8** - Production Data & Generation (version tracking, metadata filtering, chain-of-thought)
9. **v0.3.9** - Developer Experience I (REPL, debug mode)
10. **v0.3.10** - Performance & Quality Tools (profiling, metrics dashboard)
11. **v0.3.11** - Automation & Templates (Jinja2 templates, testing utilities)
12. **v0.3.12** - Production Operations (watch mode, scheduled operations)
13. **v0.3.13** - Polish & Integration (REST API, smart suggestions, accessibility)

### Total Effort
- **Estimated:** 437-501 hours
- **Features:** 50+ major features across 13 versions
- **RAGAS Target:** > 0.80 (production quality)

### Next Steps
- **v0.4.0** - LEANN Integration (vector database)
- **v0.5.0** - Multi-Modal RAG
- **v1.0.0** - Stable Release

---

## Related Documentation

- [v0.3.0 Roadmap](./README.md) - Complete overview
- [All v0.3.x versions](./README.md) - Links to all 13 versions

---

**Status:** Planned
