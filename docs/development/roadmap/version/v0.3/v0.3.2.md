# v0.3.2 - Configuration Transparency

**Category:** User Experience & Configuration

**Estimated Time:** 28-34 hours

**Status:** Planned

---

## Overview

Make ragged transparent and user-friendly through configuration personas and explainability features.

**Key Innovation:** Users understand what ragged will do BEFORE it does it.

---

## Prerequisites

**Security & Privacy Foundation (REQUIRED):**

All v0.3.x versions depend on the security and privacy infrastructure established in v0.2.10 and v0.2.11. These versions MUST be completed before implementing any v0.3.x features.

- ✅ **v0.2.10 (Security Hardening)** - Eliminates Pickle vulnerabilities, implements session isolation, establishes security testing framework
- ✅ **v0.2.11 (Privacy Infrastructure)** - Provides encryption at rest, PII detection/redaction, data lifecycle management, GDPR compliance

**Why Required:** v0.3.x features will store and process user data (metrics, REPL history, API requests). The security and privacy foundations ensure this data is protected from the start.

---

## Features

### FEAT-016: Advanced Configuration Management (10-12h)

**Priority:** Critical
**Dependencies:** None

#### Scope

Implement layered configuration system with proper inheritance and validation.

**Configuration Layers (Priority Order):**
1. Defaults (in code)
2. User config file (`~/.config/ragged/config.yml`)
3. CLI flags
4. Environment variables (highest priority)

#### Implementation

```python
# src/config/config_manager.py (NEW FILE)
"""Layered configuration management."""
from pathlib import Path
from typing import Dict, Any, Optional
import yaml
import os
from dataclasses import dataclass, asdict, field

@dataclass
class RaggedConfig:
    """
    Ragged configuration with layered overrides.

    Priority: Defaults → User file → CLI flags → Environment variables
    """
    # Retrieval settings
    retrieval_method: str = "hybrid"
    top_k: int = 5
    bm25_weight: float = 0.3
    vector_weight: float = 0.7

    # Reranking settings
    enable_reranking: bool = True
    rerank_to: int = 3
    rerank_model: str = "cross-encoder/ms-marco-MiniLM-L-6-v2"

    # Query processing
    enable_query_decomposition: bool = False
    enable_hyde: bool = False
    enable_compression: bool = False

    # Generation settings
    llm_model: str = "llama3.2:latest"
    temperature: float = 0.7
    max_tokens: int = 512

    # Confidence thresholds
    confidence_threshold: float = 0.85

    # Current persona
    persona: str = "balanced"

    @classmethod
    def load(cls, config_path: Optional[Path] = None) -> "RaggedConfig":
        """
        Load configuration with layered overrides.

        Args:
            config_path: Optional custom config file path

        Returns:
            RaggedConfig instance with merged settings
        """
        # Start with defaults
        config = cls()

        # Load user config file
        if config_path is None:
            config_path = Path.home() / ".config" / "ragged" / "config.yml"

        if config_path.exists():
            with open(config_path) as f:
                user_config = yaml.safe_load(f) or {}
                config._merge(user_config)

        # Apply environment variables
        config._apply_env_vars()

        return config

    def _merge(self, overrides: Dict[str, Any]):
        """Merge override dict into config."""
        for key, value in overrides.items():
            if hasattr(self, key):
                setattr(self, key, value)

    def _apply_env_vars(self):
        """Apply environment variable overrides."""
        env_mapping = {
            'RAGGED_RETRIEVAL_METHOD': 'retrieval_method',
            'RAGGED_TOP_K': ('top_k', int),
            'RAGGED_PERSONA': 'persona',
            'RAGGED_LLM_MODEL': 'llm_model',
        }

        for env_var, attr in env_mapping.items():
            if env_var in os.environ:
                if isinstance(attr, tuple):
                    attr_name, converter = attr
                    setattr(self, attr_name, converter(os.environ[env_var]))
                else:
                    setattr(self, attr, os.environ[env_var])

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)

    def save(self, config_path: Optional[Path] = None):
        """Save current config to file."""
        if config_path is None:
            config_path = Path.home() / ".config" / "ragged" / "config.yml"

        config_path.parent.mkdir(parents=True, exist_ok=True)

        with open(config_path, 'w') as f:
            yaml.dump(self.to_dict(), f, default_flow_style=False)

class ConfigValidator:
    """Validate configuration values."""

    def validate(self, config: RaggedConfig) -> tuple[bool, list[str]]:
        """
        Validate configuration.

        Returns:
            (is_valid, error_messages)
        """
        errors = []

        # Validate retrieval method
        if config.retrieval_method not in ["hybrid", "vector", "bm25"]:
            errors.append(f"Invalid retrieval_method: {config.retrieval_method}")

        # Validate weights
        if config.retrieval_method == "hybrid":
            if not (0 <= config.bm25_weight <= 1):
                errors.append(f"bm25_weight must be 0-1: {config.bm25_weight}")
            if not (0 <= config.vector_weight <= 1):
                errors.append(f"vector_weight must be 0-1: {config.vector_weight}")

        # Validate top_k
        if config.top_k < 1 or config.top_k > 100:
            errors.append(f"top_k must be 1-100: {config.top_k}")

        # Validate rerank_to
        if config.enable_reranking and config.rerank_to > config.top_k:
            errors.append(f"rerank_to ({config.rerank_to}) cannot exceed top_k ({config.top_k})")

        # Validate persona
        valid_personas = ["accuracy", "speed", "balanced", "research", "quick-answer"]
        if config.persona not in valid_personas:
            errors.append(f"Invalid persona: {config.persona}")

        return (len(errors) == 0, errors)
```

**CLI Integration:**
```python
# src/cli/commands/config.py (ENHANCE EXISTING)
"""Configuration management commands."""
import click
from pathlib import Path
from src.config.config_manager import RaggedConfig, ConfigValidator

@click.group()
def config():
    """Manage ragged configuration."""
    pass

@config.command()
@click.option('--format', type=click.Choice(['yaml', 'json']), default='yaml')
def show(format):
    """
    Show current configuration with all layers merged.

    Displays the effective configuration after merging:
    - Defaults
    - User config file
    - Environment variables
    """
    cfg = RaggedConfig.load()

    if format == 'yaml':
        import yaml
        click.echo(yaml.dump(cfg.to_dict(), default_flow_style=False))
    else:
        import json
        click.echo(json.dumps(cfg.to_dict(), indent=2))

@config.command()
def validate():
    """
    Validate configuration file.

    Checks for:
    - Invalid values
    - Type mismatches
    - Constraint violations
    """
    cfg = RaggedConfig.load()
    validator = ConfigValidator()

    is_valid, errors = validator.validate(cfg)

    if is_valid:
        click.echo("✓ Configuration is valid", color='green')
    else:
        click.echo("✗ Configuration has errors:", color='red')
        for error in errors:
            click.echo(f"  - {error}")

@config.command()
@click.argument('key')
@click.argument('value')
def set(key, value):
    """
    Set a configuration value.

    Examples:
        ragged config set persona accuracy
        ragged config set top_k 10
    """
    cfg = RaggedConfig.load()

    # Type conversion
    if hasattr(cfg, key):
        current_type = type(getattr(cfg, key))
        if current_type == int:
            value = int(value)
        elif current_type == float:
            value = float(value)
        elif current_type == bool:
            value = value.lower() in ['true', '1', 'yes']

        setattr(cfg, key, value)

        # Validate before saving
        validator = ConfigValidator()
        is_valid, errors = validator.validate(cfg)

        if is_valid:
            cfg.save()
            click.echo(f"✓ Set {key} = {value}")
        else:
            click.echo("✗ Invalid configuration:", color='red')
            for error in errors:
                click.echo(f"  - {error}")
    else:
        click.echo(f"✗ Unknown config key: {key}", color='red')

@config.command()
@click.option('--output', type=click.Path(), help='Output path')
def generate(output):
    """
    Generate default configuration file.

    Creates a config.yml with all available options documented.
    """
    cfg = RaggedConfig()

    if output:
        output_path = Path(output)
    else:
        output_path = Path.home() / ".config" / "ragged" / "config.yml"

    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as f:
        f.write("# ragged Configuration\n")
        f.write("# Generated configuration with defaults\n\n")
        import yaml
        yaml.dump(cfg.to_dict(), f, default_flow_style=False)

    click.echo(f"✓ Generated config at: {output_path}")
```

#### Testing Requirements

- [ ] Test configuration layer precedence (defaults → file → env)
- [ ] Test config validation (invalid values, constraints)
- [ ] Test config save/load round-trip
- [ ] Test CLI commands (show, validate, set, generate)
- [ ] Test environment variable overrides

#### Files to Create/Modify

- `src/config/config_manager.py` (~250 lines)
- `src/cli/commands/config.py` (~150 lines added)
- `tests/config/test_config_manager.py` (~150 lines)
- `tests/cli/test_config.py` (~100 lines)

#### Acceptance Criteria

- ✅ Configuration loads from all 4 layers correctly
- ✅ Precedence order enforced (env > CLI > file > defaults)
- ✅ Validation catches all constraint violations
- ✅ CLI commands work as expected

---

### FEAT-017: Configuration Personas (4-5h)

**Priority:** High
**Dependencies:** FEAT-016 (Configuration Management)

#### Scope

Implement pre-configured personas for common use cases, making ragged approachable for non-experts.

**Built-in Personas:**
1. **accuracy** - Maximum quality, slower
2. **speed** - Fast answers
3. **balanced** - Default (good quality/speed trade-off)
4. **research** - Deep exploration
5. **quick-answer** - Single best answer

#### Implementation

```python
# src/config/personas.py (NEW FILE)
"""Configuration personas for common use cases."""
from dataclasses import dataclass
from typing import Dict

@dataclass
class PersonaConfig:
    """Persona configuration template."""
    name: str
    description: str
    retrieval_method: str
    top_k: int
    enable_reranking: bool
    rerank_to: int
    enable_query_decomposition: bool
    enable_hyde: bool
    enable_compression: bool
    confidence_threshold: float

class PersonaManager:
    """Manage configuration personas."""

    # Built-in personas
    PERSONAS: Dict[str, PersonaConfig] = {
        "accuracy": PersonaConfig(
            name="accuracy",
            description="Maximum quality, slower responses",
            retrieval_method="hybrid",
            top_k=10,
            enable_reranking=True,
            rerank_to=3,
            enable_query_decomposition=True,
            enable_hyde=False,
            enable_compression=True,
            confidence_threshold=0.95
        ),
        "speed": PersonaConfig(
            name="speed",
            description="Fast answers, good quality",
            retrieval_method="vector",
            top_k=3,
            enable_reranking=False,
            rerank_to=0,
            enable_query_decomposition=False,
            enable_hyde=False,
            enable_compression=False,
            confidence_threshold=0.80
        ),
        "balanced": PersonaConfig(
            name="balanced",
            description="Default - balanced quality and speed",
            retrieval_method="hybrid",
            top_k=5,
            enable_reranking=True,
            rerank_to=5,
            enable_query_decomposition=False,  # Auto-detect
            enable_hyde=False,
            enable_compression=False,  # Auto-detect
            confidence_threshold=0.85
        ),
        "research": PersonaConfig(
            name="research",
            description="Deep exploration, comprehensive results",
            retrieval_method="hybrid",
            top_k=30,
            enable_reranking=True,
            rerank_to=10,
            enable_query_decomposition=True,
            enable_hyde=True,
            enable_compression=False,
            confidence_threshold=0.90
        ),
        "quick-answer": PersonaConfig(
            name="quick-answer",
            description="Single best answer, fastest",
            retrieval_method="hybrid",
            top_k=1,
            enable_reranking=False,
            rerank_to=0,
            enable_query_decomposition=False,
            enable_hyde=False,
            enable_compression=False,
            confidence_threshold=0.75
        )
    }

    @classmethod
    def get_persona(cls, name: str) -> PersonaConfig:
        """Get persona by name."""
        if name not in cls.PERSONAS:
            raise ValueError(f"Unknown persona: {name}")
        return cls.PERSONAS[name]

    @classmethod
    def list_personas(cls) -> Dict[str, str]:
        """List all personas with descriptions."""
        return {
            name: persona.description
            for name, persona in cls.PERSONAS.items()
        }

    @classmethod
    def apply_persona(cls, config: 'RaggedConfig', persona_name: str):
        """Apply persona settings to config."""
        persona = cls.get_persona(persona_name)

        config.retrieval_method = persona.retrieval_method
        config.top_k = persona.top_k
        config.enable_reranking = persona.enable_reranking
        config.rerank_to = persona.rerank_to
        config.enable_query_decomposition = persona.enable_query_decomposition
        config.enable_hyde = persona.enable_hyde
        config.enable_compression = persona.enable_compression
        config.confidence_threshold = persona.confidence_threshold
        config.persona = persona_name
```

**CLI Integration:**
```python
# Modify src/cli/commands/query.py
@click.option('--persona', type=click.Choice(['accuracy', 'speed', 'balanced', 'research', 'quick-answer']))
def query(query_text, persona, ...):
    """Execute query with optional persona."""
    from src.config.personas import PersonaManager

    config = RaggedConfig.load()

    # Apply persona if specified
    if persona:
        PersonaManager.apply_persona(config, persona)

    # Continue with query using config...

# Add to src/cli/commands/config.py
@config.command()
def list_personas():
    """List available configuration personas."""
    from src.config.personas import PersonaManager

    personas = PersonaManager.list_personas()

    click.echo("Available personas:\n")
    for name, description in personas.items():
        click.echo(f"  {name:15} - {description}")

@config.command()
@click.argument('persona')
def set_default_persona(persona):
    """Set default persona in config file."""
    from src.config.personas import PersonaManager

    # Validate persona exists
    PersonaManager.get_persona(persona)

    config = RaggedConfig.load()
    PersonaManager.apply_persona(config, persona)
    config.save()

    click.echo(f"✓ Set default persona to: {persona}")
```

**Usage Examples:**
```bash
# Use persona for single query
ragged query --persona accuracy "What is machine learning?"

# Set default persona
ragged config set-default-persona research

# List available personas
ragged config list-personas
```

#### Testing Requirements

- [ ] Test all 5 built-in personas apply correctly
- [ ] Test persona validation (invalid names)
- [ ] Test CLI persona flag
- [ ] Test default persona persistence
- [ ] Test persona list command

#### Files to Create/Modify

- `src/config/personas.py` (~150 lines)
- `src/cli/commands/query.py` (modify for `--persona` flag)
- `src/cli/commands/config.py` (add persona commands)
- `tests/config/test_personas.py` (~100 lines)

#### Acceptance Criteria

- ✅ All 5 personas defined and functional
- ✅ Persona flag works on query command
- ✅ Default persona can be set and persisted
- ✅ Persona list displays correctly

---

### FEAT-018: Transparency & Explainability (4-5h)

**Priority:** High
**Dependencies:** FEAT-016, FEAT-017

#### Scope

Implement `ragged explain` command to show users what will happen before execution.

**Transparency Goals:**
- Users understand what ragged will do
- Decision-making is visible
- Performance expectations are clear

#### Implementation

```python
# src/cli/commands/explain.py (NEW FILE)
"""Explainability commands."""
import click
from src.config.config_manager import RaggedConfig
from src.config.personas import PersonaManager

@click.group()
def explain():
    """Explain ragged's decision-making."""
    pass

@explain.command()
@click.argument('query_text')
@click.option('--persona', help='Persona to explain')
def query(query_text, persona):
    """
    Explain what will happen when executing this query.

    Shows the pipeline without actually executing it.
    """
    config = RaggedConfig.load()

    # Apply persona if specified
    if persona:
        PersonaManager.apply_persona(config, persona)

    click.echo(f"Query: {query_text}\n")
    click.echo("Pipeline Configuration:")
    click.echo(f"  Persona: {config.persona}")
    click.echo(f"  Retrieval: {config.retrieval_method}")
    click.echo(f"  Chunks to retrieve: {config.top_k}")

    if config.enable_reranking:
        click.echo(f"  Reranking: Yes (top-{config.top_k} → top-{config.rerank_to})")
    else:
        click.echo(f"  Reranking: No")

    click.echo(f"\nQuery Processing:")
    if config.enable_query_decomposition:
        click.echo(f"  Decomposition: Enabled")
    else:
        click.echo(f"  Decomposition: Disabled")

    if config.enable_hyde:
        click.echo(f"  HyDE: Enabled")
    else:
        click.echo(f"  HyDE: Disabled")

    if config.enable_compression:
        click.echo(f"  Compression: Enabled")
    else:
        click.echo(f"  Compression: Disabled")

    click.echo(f"\nGeneration:")
    click.echo(f"  Model: {config.llm_model}")
    click.echo(f"  Temperature: {config.temperature}")
    click.echo(f"  Confidence threshold: {config.confidence_threshold}")

    # Estimate processing time
    time_estimate = _estimate_query_time(config)
    click.echo(f"\nEstimated time: {time_estimate}")

def _estimate_query_time(config: RaggedConfig) -> str:
    """Estimate query processing time based on config."""
    base_time = 2  # Base retrieval + generation

    if config.enable_query_decomposition:
        base_time += 1

    if config.enable_hyde:
        base_time += 1

    if config.enable_reranking:
        base_time += 2

    if config.enable_compression:
        base_time += 1

    return f"{base_time}-{base_time + 3} seconds"

@explain.command()
def config():
    """
    Explain current configuration and where values came from.

    Shows the configuration layer precedence.
    """
    # Load defaults
    defaults = RaggedConfig()

    # Load merged config
    config = RaggedConfig.load()

    click.echo("Configuration Sources:\n")

    # Compare to show which values were overridden
    for key in defaults.to_dict().keys():
        default_val = getattr(defaults, key)
        current_val = getattr(config, key)

        if default_val != current_val:
            click.echo(f"  {key}: {current_val} (overridden from {default_val})")
        else:
            click.echo(f"  {key}: {current_val} (default)")
```

**Usage Examples:**
```bash
# Explain what a query will do
ragged explain query "What is RAG?"

# Explain with different persona
ragged explain query --persona accuracy "What is RAG?"

# Explain current config
ragged explain config
```

#### Testing Requirements

- [ ] Test explain query output format
- [ ] Test explain with different personas
- [ ] Test explain config shows overrides
- [ ] Test time estimation accuracy
- [ ] Test output formatting

#### Files to Create

- `src/cli/commands/explain.py` (~150 lines)
- `tests/cli/test_explain.py` (~100 lines)

#### Acceptance Criteria

- ✅ Explain command shows accurate pipeline preview
- ✅ Time estimates within 50% of actual
- ✅ Config source tracking works
- ✅ Output is clear and user-friendly

---

## Implementation Phases

### Phase 1: Design & Planning (4-5h)

**Session 1: Configuration Architecture (2-3h)**
- Review existing configuration system
- Design layered configuration architecture
- Plan persona system design
- Use ux-architect agent for persona UX review

**Session 2: User Experience Design (2h)**
- Design `explain` command output format
- Design persona switching UX
- Create mockups for CLI output
- Validate with ux-architect agent

**Deliverables:**
- Configuration architecture documented
- Persona UX validated
- CLI output format designed

### Phase 2: Core Implementation (18-22h)

**Session 3: Configuration Manager (5-6h)**
- Create `src/config/config_manager.py`
- Implement `RaggedConfig` dataclass
- Implement layered loading (defaults → file → env)
- Implement `ConfigValidator` class
- Add validation logic

**Session 4: Configuration CLI Commands (5-6h)**
- Enhance `src/cli/commands/config.py`
- Implement `config show` command
- Implement `config validate` command
- Implement `config set` command
- Implement `config generate` command
- Test all config commands

**Session 5: Persona System (4-5h)**
- Create `src/config/personas.py`
- Implement `PersonaConfig` dataclass
- Implement `PersonaManager` class
- Define all 5 built-in personas
- Add persona application logic

**Session 6: Persona CLI Integration (4-5h)**
- Modify `src/cli/commands/query.py` for `--persona` flag
- Add `config list-personas` command
- Add `config set-default-persona` command
- Test persona switching
- Validate persona configurations

**Deliverables:**
- Configuration system fully functional
- All 5 personas defined
- CLI integration complete

### Phase 3: Transparency Features (4-5h)

**Session 7: Explain Command (4-5h)**
- Create `src/cli/commands/explain.py`
- Implement `explain query` command
- Implement `explain config` command
- Add time estimation logic
- Format output for readability

**Deliverables:**
- Explain command functional
- Clear, informative output

### Phase 4: Testing & Documentation (6-8h)

**Session 8: Unit Tests (3-4h)**
- Create `tests/config/test_config_manager.py`
- Create `tests/config/test_personas.py`
- Create `tests/cli/test_config.py`
- Create `tests/cli/test_explain.py`
- Achieve 100% coverage for new code

**Session 9: Integration Testing (2-3h)**
- Test configuration layer precedence
- Test persona switching end-to-end
- Test explain command accuracy
- Validate time estimates
- Test validation catches errors

**Session 10: Documentation (1-2h)**
- Use documentation-architect agent for planning
- Document configuration system in user guides
- Document persona usage
- Add examples for all features
- Document explain command

**Deliverables:**
- All tests passing
- Complete user documentation

### Phase 5: Review & Release (2-3h)

**Session 11: Agent Review & Commit (2-3h)**
- Run documentation-auditor agent
- Fix any issues identified
- Use git-documentation-committer agent
- Tag v0.3.2 release

**Deliverables:**
- Documentation audited
- Release tagged

---

## Technical Architecture

### Module Structure

```
src/
├── config/
│   ├── __init__.py
│   ├── config_manager.py           # Layered configuration (250 lines)
│   │   ├── class RaggedConfig
│   │   ├── class ConfigValidator
│   │   └── Configuration loading/saving logic
│   └── personas.py                 # Persona management (150 lines)
│       ├── class PersonaConfig
│       ├── class PersonaManager
│       └── 5 built-in persona definitions
│
└── cli/commands/
    ├── config.py                   # Config commands (enhanced)
    │   ├── config show
    │   ├── config validate
    │   ├── config set
    │   ├── config generate
    │   ├── config list-personas
    │   └── config set-default-persona
    ├── query.py                    # Enhanced with --persona flag
    └── explain.py                  # Transparency commands (150 lines)
        ├── explain query
        └── explain config

tests/
├── config/
│   ├── test_config_manager.py      # Config tests (150 lines)
│   └── test_personas.py            # Persona tests (100 lines)
└── cli/
    ├── test_config.py              # Config CLI tests (100 lines)
    └── test_explain.py             # Explain CLI tests (100 lines)
```

### Configuration Data Flow

**Loading Configuration:**
```
Defaults (in code)
    ↓
User config file (~/.config/ragged/config.yml)
    ↓ (merge)
Environment variables (RAGGED_*)
    ↓ (override)
CLI flags (--persona, --top-k, etc.)
    ↓ (final override)
Effective Configuration
    ↓
Used by query pipeline
```

**Persona Application:**
```
User request: ragged query --persona accuracy "question"
    ↓
Load base configuration
    ↓
PersonaManager.get_persona("accuracy")
    ↓
PersonaManager.apply_persona(config, "accuracy")
    ↓
Config modified with persona settings:
    - retrieval_method = "hybrid"
    - top_k = 10
    - enable_reranking = True
    - rerank_to = 3
    - etc.
    ↓
Query executes with persona config
```

### API Interfaces

**RaggedConfig Interface:**
```python
class RaggedConfig:
    @classmethod
    def load(config_path: Optional[Path] = None) -> RaggedConfig

    def save(config_path: Optional[Path] = None)

    def to_dict() -> Dict[str, Any]

    def _merge(overrides: Dict[str, Any])

    def _apply_env_vars()
```

**PersonaManager Interface:**
```python
class PersonaManager:
    @classmethod
    def get_persona(name: str) -> PersonaConfig

    @classmethod
    def list_personas() -> Dict[str, str]

    @classmethod
    def apply_persona(config: RaggedConfig, persona_name: str)
```

**ConfigValidator Interface:**
```python
class ConfigValidator:
    def validate(config: RaggedConfig) -> tuple[bool, list[str]]
```

### Integration Points

1. **Query Command → Configuration**
   - `ragged query --persona X` loads config and applies persona
   - All query parameters respect config settings
   - CLI flags override config (highest precedence)

2. **Explain Command → Configuration**
   - Loads current configuration
   - Shows effective settings after all merges
   - Estimates behaviour without execution

3. **Config Commands → File System**
   - `config show` reads and displays merged config
   - `config set` modifies and saves user config file
   - `config validate` checks constraints

---

## Risk Analysis & Mitigation

### Technical Risks

**Risk 1: Configuration Precedence Confusion**
- **Impact:** Medium - Users may not understand which config applies
- **Probability:** Medium - Layered config is complex
- **Mitigation:**
  - Clear documentation of precedence order
  - `explain config` shows effective values and sources
  - Validation warns about conflicts
  - Use `config show` to display effective configuration
- **Detection:** User feedback, integration tests

**Risk 2: Persona Design Mismatch**
- **Impact:** High - Poor personas frustrate users
- **Probability:** Medium - Hard to predict user needs
- **Mitigation:**
  - Use ux-architect agent for persona design review
  - Start with well-defined use cases
  - Allow user customisation (future: custom personas)
  - Document persona trade-offs clearly
- **Detection:** User testing, feedback collection

**Risk 3: Configuration Validation Completeness**
- **Impact:** Medium - Invalid configs cause errors
- **Probability:** Low - Good test coverage
- **Mitigation:**
  - Comprehensive validation rules
  - Test all constraint violations
  - Clear error messages
  - Fail-fast on invalid configs
- **Detection:** Unit tests catch validation gaps

### Performance Risks

**Risk 4: Configuration Loading Overhead**
- **Impact:** Low - Only happens once per command
- **Probability:** Low - YAML loading is fast
- **Mitigation:**
  - Simple YAML files (no complex parsing)
  - Cache loaded config if needed
  - Config files are small (<1KB)
- **Detection:** Performance profiling

### UX Risks

**Risk 5: Explain Command Accuracy**
- **Impact:** High - Inaccurate explanations break trust
- **Probability:** Medium - Pipeline complexity
- **Mitigation:**
  - Test explain output matches actual behavior
  - Update explain when pipeline changes
  - Time estimates are ranges, not exact
  - Clearly mark estimates as approximate
- **Detection:** Integration tests, manual validation

**Risk 6: Too Many Configuration Options**
- **Impact:** Medium - Overwhelming for beginners
- **Probability:** Medium - 10+ config options
- **Mitigation:**
  - Personas hide complexity for beginners
  - Advanced users can access raw config
  - Documentation progressive disclosure
  - Defaults work well for most users
- **Detection:** User feedback, usability testing

---

## Quality Gates

### Functional Requirements

- [ ] Configuration loads from all 4 layers (defaults, file, env, CLI)
- [ ] Precedence order correct: env > CLI flags > file > defaults
- [ ] All 5 personas defined and apply correctly
- [ ] `config show` displays effective configuration
- [ ] `config validate` catches all constraint violations
- [ ] `config set` modifies and saves configuration
- [ ] `config generate` creates valid config file
- [ ] `config list-personas` displays all 5 personas
- [ ] `config set-default-persona` persists persona choice
- [ ] `query --persona X` applies persona correctly
- [ ] `explain query` shows accurate pipeline preview
- [ ] `explain config` shows configuration sources

### Performance Requirements

- [ ] Configuration loading < 50ms
- [ ] Persona application < 10ms
- [ ] Config validation < 20ms
- [ ] No performance regression on queries

### Code Quality Requirements

- [ ] 100% test coverage for new code
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Type hints complete
- [ ] Docstrings complete (British English)
- [ ] No linting errors
- [ ] Code follows project style guide

### Documentation Requirements

- [ ] Configuration system documented
- [ ] All 5 personas documented with use cases
- [ ] Layered configuration explained
- [ ] Environment variables documented
- [ ] Explain command usage documented
- [ ] Examples provided for all features
- [ ] documentation-auditor check passed
- [ ] British English compliance verified

### UX Requirements

- [ ] ux-architect review passed for personas
- [ ] Persona names intuitive and descriptive
- [ ] Explain output clear and readable
- [ ] Time estimates within 50% of actual
- [ ] Error messages helpful and actionable
- [ ] Configuration file human-readable

---

## Execution Checklist

### Pre-Implementation Setup

- [ ] Create feature branch: `git checkout -b feature/v0.3.2-configuration-transparency`
- [ ] Review existing configuration code
- [ ] Set up time tracking for this version
- [ ] Prepare development environment
- [ ] Schedule ux-architect agent session

### Session-by-Session Tasks

**Session 1: Configuration Architecture**
- [ ] Review current `src/config/` structure
- [ ] Design layered configuration system
- [ ] Document precedence rules
- [ ] Plan file locations and formats
- [ ] Create architecture decision record

**Session 2: User Experience Design**
- [ ] Use ux-architect agent for persona design review
- [ ] Design persona names and descriptions
- [ ] Create `explain` command output mockups
- [ ] Validate persona trade-offs
- [ ] Document persona use cases

**Session 3: Configuration Manager**
- [ ] Create `src/config/config_manager.py`
- [ ] Implement `RaggedConfig` dataclass
- [ ] Implement `.load()` method (defaults → file → env)
- [ ] Implement `.save()` method
- [ ] Implement `._merge()` and `._apply_env_vars()`
- [ ] Implement `ConfigValidator` class
- [ ] Add validation rules
- [ ] Test manually with sample configs

**Session 4: Configuration CLI Commands**
- [ ] Open `src/cli/commands/config.py`
- [ ] Implement `config show` command
- [ ] Implement `config validate` command
- [ ] Implement `config set` command
- [ ] Implement `config generate` command
- [ ] Test each command manually
- [ ] Verify YAML/JSON output formatting

**Session 5: Persona System**
- [ ] Create `src/config/personas.py`
- [ ] Implement `PersonaConfig` dataclass
- [ ] Implement `PersonaManager` class
- [ ] Define "accuracy" persona
- [ ] Define "speed" persona
- [ ] Define "balanced" persona
- [ ] Define "research" persona
- [ ] Define "quick-answer" persona
- [ ] Implement `.apply_persona()` method

**Session 6: Persona CLI Integration**
- [ ] Modify `src/cli/commands/query.py`
- [ ] Add `--persona` flag to query command
- [ ] Integrate persona application logic
- [ ] Add `config list-personas` command
- [ ] Add `config set-default-persona` command
- [ ] Test persona switching manually
- [ ] Verify each persona applies correct settings

**Session 7: Explain Command**
- [ ] Create `src/cli/commands/explain.py`
- [ ] Implement `explain query` command
- [ ] Implement `explain config` command
- [ ] Add `_estimate_query_time()` helper
- [ ] Format output for readability
- [ ] Test with all 5 personas
- [ ] Validate time estimates

**Session 8: Unit Tests**
- [ ] Create `tests/config/test_config_manager.py`
- [ ] Test configuration loading (all layers)
- [ ] Test precedence order
- [ ] Test validation (all rules)
- [ ] Create `tests/config/test_personas.py`
- [ ] Test all 5 personas
- [ ] Test persona application
- [ ] Create `tests/cli/test_config.py`
- [ ] Test all config commands
- [ ] Create `tests/cli/test_explain.py`
- [ ] Test explain commands
- [ ] Run `pytest --cov` and verify 100% coverage

**Session 9: Integration Testing**
- [ ] Test: defaults → file → env → CLI precedence
- [ ] Test: persona switching end-to-end
- [ ] Test: `explain query` matches actual behavior
- [ ] Test: time estimates reasonable
- [ ] Test: validation catches all invalid configs
- [ ] Test: environment variables override file
- [ ] Fix any issues discovered

**Session 10: Documentation**
- [ ] Use documentation-architect agent for structure
- [ ] Document configuration system in user guide
- [ ] Document layered configuration with examples
- [ ] Document all 5 personas with use cases
- [ ] Document `explain` command usage
- [ ] Add environment variable reference
- [ ] Create configuration examples
- [ ] Add to CHANGELOG.md

**Session 11: Agent Review & Commit**
- [ ] Run documentation-auditor agent
- [ ] Fix British English issues
- [ ] Fix cross-reference issues
- [ ] Fix any SSOT violations
- [ ] Run `/check-british` command
- [ ] Use git-documentation-committer agent
- [ ] Verify commit message follows conventions
- [ ] Push to GitHub
- [ ] Create tag: `git tag v0.3.2`
- [ ] Push tag: `git push origin v0.3.2`

### Post-Implementation

- [ ] Update `docs/development/implementation/version/v0.3/v0.3.2.md` with results
- [ ] Record actual hours spent in time log
- [ ] Compare actual vs estimated effort
- [ ] Document lessons learned
- [ ] Collect user feedback on personas
- [ ] Update progress in v0.3/README.md
- [ ] Prepare for v0.3.3

---

## Agent Workflow (8-10h)

1. **ux-architect (2h):** Persona design review
2. **documentation-architect (2h):** User guide structure
3. **documentation-auditor (2-3h):** Comprehensive review
4. **git-documentation-committer (2-3h):** Commit

---

## Deliverables

- Configuration personas with simple switching
- `ragged explain` command for transparency
- Layered configuration management
- User-customisable personas

---

## Success Criteria

- ✅ Users can switch personas with single flag
- ✅ `explain` shows accurate pipeline preview
- ✅ Custom personas work correctly
- ✅ Configuration validation catches errors

---

## Related Documentation

- [v0.3.0 Roadmap](./README.md#configuration-personas-design) - Persona specifications
- [Configuration Features](./features/configuration-management.md) - Detailed specs

---

**Status:** Planned
